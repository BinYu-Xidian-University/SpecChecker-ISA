#coding=utf-8
###############################################################################
#
# Generate an analysis report from a result database
#
# Author: Maxime Arthaud
#
# Contact: ikos@lists.nasa.gov
#
# Notices:
#
# Copyright (c) 2011-2018 United States Government as represented by the
# Administrator of the National Aeronautics and Space Administration.
# All Rights Reserved.
#
# Disclaimers:
#
# No Warranty: THE SUBJECT SOFTWARE IS PROVIDED "AS IS" WITHOUT ANY WARRANTY OF
# ANY KIND, EITHER EXPRESSED, IMPLIED, OR STATUTORY, INCLUDING, BUT NOT LIMITED
# TO, ANY WARRANTY THAT THE SUBJECT SOFTWARE WILL CONFORM TO SPECIFICATIONS,
# ANY IMPLIED WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE,
# OR FREEDOM FROM INFRINGEMENT, ANY WARRANTY THAT THE SUBJECT SOFTWARE WILL BE
# ERROR FREE, OR ANY WARRANTY THAT DOCUMENTATION, IF PROVIDED, WILL CONFORM TO
# THE SUBJECT SOFTWARE. THIS AGREEMENT DOES NOT, IN ANY MANNER, CONSTITUTE AN
# ENDORSEMENT BY GOVERNMENT AGENCY OR ANY PRIOR RECIPIENT OF ANY RESULTS,
# RESULTING DESIGNS, HARDWARE, SOFTWARE PRODUCTS OR ANY OTHER APPLICATIONS
# RESULTING FROM USE OF THE SUBJECT SOFTWARE.  FURTHER, GOVERNMENT AGENCY
# DISCLAIMS ALL WARRANTIES AND LIABILITIES REGARDING THIRD-PARTY SOFTWARE,
# IF PRESENT IN THE ORIGINAL SOFTWARE, AND DISTRIBUTES IT "AS IS."
#
# Waiver and Indemnity:  RECIPIENT AGREES TO WAIVE ANY AND ALL CLAIMS AGAINST
# THE UNITED STATES GOVERNMENT, ITS CONTRACTORS AND SUBCONTRACTORS, AS WELL
# AS ANY PRIOR RECIPIENT.  IF RECIPIENT'S USE OF THE SUBJECT SOFTWARE RESULTS
# IN ANY LIABILITIES, DEMANDS, DAMAGES, EXPENSES OR LOSSES ARISING FROM SUCH
# USE, INCLUDING ANY DAMAGES FROM PRODUCTS BASED ON, OR RESULTING FROM,
# RECIPIENT'S USE OF THE SUBJECT SOFTWARE, RECIPIENT SHALL INDEMNIFY AND HOLD
# HARMLESS THE UNITED STATES GOVERNMENT, ITS CONTRACTORS AND SUBCONTRACTORS,
# AS WELL AS ANY PRIOR RECIPIENT, TO THE EXTENT PERMITTED BY LAW.
# RECIPIENT'S SOLE REMEDY FOR ANY SUCH MATTER SHALL BE THE IMMEDIATE,
# UNILATERAL TERMINATION OF THIS AGREEMENT.
#
###############################################################################
import argparse
import collections
import functools
import io
import itertools
import json
import operator
import os
import os.path
import sqlite3
import sys

from ikos import args
from ikos import colors
from ikos.abs_int import Signedness, MachineInt, Interval, Congruence
from ikos.colors import bold, bold_blue, bold_green, bold_magenta, bold_red, \
    bold_yellow
from ikos.enums import Result, CheckKind, CheckerName, ValueKind, \
    StatementKind, MemoryLocationKind, FunctionCallCheckKind, \
    BufferOverflowCheckKind, ChecksTable
from ikos.log import printf_utf8_to_gbk, printf
from ikos.output_db import OutputDatabase, File, Function, Statement, \
    CallContext, Operand, NumOperandPair, MemoryLocation, Check


#TODO: yuna-改成中文信息时，使用unicode字符串比如 u'中文'

##################
# timing results #
##################

# filter method
def is_filtered_by_result_level(result_level):
    if result_level == None:
        return False
    if result_level == 'high':
        return True

def is_filtered_by_message(result_level, message):
    # 
    if not is_filtered_by_result_level(result_level):
        return False

    if not isinstance(message, (str,unicode)):
        return False

    if message.find(u'无法计算') != -1:     
        return True

    return False

def is_filtered_by_interval(result_level, interval):
    if not is_filtered_by_result_level(result_level):
        return False
    if not isinstance(interval, Interval):
        return False 
    
    if interval.is_top() or interval.is_bottom():
        return True

    return False

def is_filtered_by_offset(result_level, offset):
    if not is_filtered_by_result_level(result_level):
        return False
    if not isinstance(offset, Interval):
        return False 
    
    if offset.ub.is_max():
        return True

    return False

def is_filtered_by_check_kind(result_level,check_kind):
    if not is_filtered_by_result_level(result_level):
        return False
    filter_checker_kinds = [CheckKind.UNEXPECTED_OPERAND,
                            CheckKind.NULL_POINTER_COMPARISON,
                            CheckKind.INVALID_POINTER_COMPARISON,
                            CheckKind.POINTER_COMPARISON,
                            CheckKind.POINTER_OVERFLOW,
                            CheckKind.INVALID_POINTER_DEREF,
                            CheckKind.UNKNOWN_MEMORY_ACCESS,
                            CheckKind.IGNORED_STORE,
                            CheckKind.IGNORED_MEMORY_COPY,
                            CheckKind.IGNORED_MEMORY_MOVE,
                            CheckKind.IGNORED_MEMORY_SET,
                            CheckKind.IGNORED_FREE,
                            CheckKind.IGNORED_CALL_SIDE_EFFECT,
                            CheckKind.FUNCTION_CALL_INLINE_ASSEMBLY,
                            CheckKind.UNKNOWN_FUNCTION_CALL_POINTER]

    used_checker_kinds = [
            CheckKind.UNREACHABLE,
            CheckKind.ASSERT,
            CheckKind.POINTER_OVERFLOW,
            CheckKind.NULL_POINTER_DEREF,
            CheckKind.UNINITIALIZED_VARIABLE,
            CheckKind.DIVISION_BY_ZERO,
            CheckKind.SHIFT_COUNT,
            CheckKind.SIGNED_INT_UNDERFLOW,
            CheckKind.SIGNED_INT_OVERFLOW,
            CheckKind.UNSIGNED_INT_UNDERFLOW,
            CheckKind.UNSIGNED_INT_OVERFLOW,
            CheckKind.POINTER_COMPARISON,
            CheckKind.UNALIGNED_POINTER,
            CheckKind.BUFFER_OVERFLOW,
            CheckKind.STRCPY_BUFFER_OVERFLOW,
            CheckKind.FUNCTION_CALL,
            CheckKind.FREE]
    # check twice
    if check_kind in used_checker_kinds:
        return False
    elif check_kind in filter_checker_kinds:
        return True

    return False

def format_time(elapsed):
    ''' Format an elapsed time.

    >>> format_time(3.1415)
    '3.142 sec'
    >>> format_time(2 * 3600 * 24 + 23 * 3600 + 42 * 60 + 3.20498)
    '2 day 23 hour 42 min 3.205 sec'
    '''
    s = []

    if elapsed >= 3600 * 24:
        s.append('%d day' % int(elapsed // (3600 * 24)))
        elapsed %= 3600 * 24

    if elapsed >= 3600:
        s.append('%d hour' % int(elapsed // 3600))
        elapsed %= 3600

    if elapsed >= 60:
        s.append('%d min' % int(elapsed // 60))
        elapsed %= 60

    s.append('%.3f sec' % elapsed)
    return ' '.join(s)


def print_timing_results(db, full=True, sort=True):
    ''' Print the timing results from the database '''
    results = db.load_timing_results(full, sort)

    printf_utf8_to_gbk(bold(u'时间统计信息:') + '\n')
    name_width = max(len(name) for name, _ in results)
    for name, elapsed in results:
        printf_utf8_to_gbk(u'%s: %s\n', name.ljust(name_width), format_time(elapsed))


###########
# summary #
###########


# Represents a check, as a hashable type
CheckTuple = collections.namedtuple('CheckTuple', ('kind','chekcer', 'operands', 'info'))


def generate_statement_result(checks, keep_oks=True, keep_checkers=True):
    '''
    Generate a result for a list of checks on a specific statement
    and call context
    '''
    result = Result.OK
    errors = set()
    warnings = set()
    oks = set() if keep_oks else None
    checkers = set() if keep_checkers else None

    for check in checks:
        if keep_checkers:
            checkers.add(check[ChecksTable.CHECKER])

        status = check[ChecksTable.STATUS]

        if status == Result.UNREACHABLE:
            result = Result.UNREACHABLE

            if keep_checkers:
                continue  # keep iterating
            else:
                break  # exit early

        check = CheckTuple(check[ChecksTable.KIND],
                           check[ChecksTable.CHECKER],
                           check[ChecksTable.OPERANDS],
                           check[ChecksTable.INFO])

        if status == Result.ERROR:
            result = Result.ERROR
            errors.add(check)
        elif status == Result.WARNING:
            if result == Result.OK:
                result = Result.WARNING
            warnings.add(check)
        elif status == Result.OK:
            if keep_oks:
                oks.add(check)
        else:
            assert False, 'unexpected status'

    return result, errors, warnings, oks, checkers


class Summary:
    ''' Represents a summary '''

    def __init__(self, ok, error, warning, unreachable):
        self.ok = ok
        self.error = error
        self.warning = warning
        self.unreachable = unreachable

    @property
    def total(self):
        return self.ok + self.error + self.warning + self.unreachable


def generate_summary(db):
    '''
    Return the analysis summary: number of errors, warnings, ok and
    unreachable per checked statements.
    '''
    summary = Summary(ok=0, error=0, warning=0, unreachable=0)

    c = db.con.cursor()
    order_by = 'statement_id, call_context_id'
    c.execute('SELECT * FROM checks ORDER BY %s' % order_by)

    stmt_id_key = operator.itemgetter(ChecksTable.STATEMENT_ID)
    context_id_key = operator.itemgetter(ChecksTable.CALL_CONTEXT_ID)

    for statement_id, statement_checks in itertools.groupby(c,
                                                            key=stmt_id_key):
        # Iterate over the checks for statement = statement_id
        statement_results = set()
        statement_checkers = set()
        statement_errors = set()
        statement_warnings = set()

        for context_id, checks in itertools.groupby(statement_checks,
                                                    key=context_id_key):
            # Iterate over the checks for statement = statement_id
            # and context = context_id
            result, errors, warnings, _, checkers = \
                generate_statement_result(checks,
                                          keep_oks=False,
                                          keep_checkers=True)
            statement_results.add(result)
            statement_checkers.update(checkers)
            statement_errors.update(errors)
            statement_warnings.update(warnings)

        if statement_results == {Result.UNREACHABLE}:
            # Statement is unreachable for all the calling contexts,
            # check that it comes from dca
            if CheckerName.DEAD_CODE in statement_checkers:
                # Statement is never reachable
                summary.unreachable += 1
        else:
            if Result.OK in statement_results:
                # Some paths are safe
                summary.ok += 1

            summary.error += len(statement_errors)
            summary.warning += len(statement_warnings)

    c.close()
    return summary


def print_summary(db, full=True):
    ''' Print the analysis summary from the database '''
    summary = generate_summary(db)

    printf_utf8_to_gbk(bold(u'结论:') + '\n')

    if full:
        printf_utf8_to_gbk(u'所有的检查数        : %s\n',
               bold(summary.total))
        printf_utf8_to_gbk(u'所有的不可达检查数  : %s\n',
               bold_magenta(summary.unreachable)
               if summary.unreachable
               else '0')
        printf_utf8_to_gbk(u'安全的检查数        : %s\n',
               bold_green(summary.ok)
               if summary.ok
               else '0')
        printf_utf8_to_gbk(u'不安全的检查数      : %s\n',
               bold_red(summary.error)
               if summary.error
               else '0')
        printf_utf8_to_gbk(u'所有的警告数        : %s\n',
               bold_yellow(summary.warning)
               if summary.warning
               else '0')
        printf_utf8_to_gbk('\n')

    if summary.error == 0 and summary.warning == 0:
        printf_utf8_to_gbk(bold_green(u'程序是安全的') + '\n')
    else:
        if summary.error != 0:
            printf_utf8_to_gbk(bold_red(u'程序不安全') + '\n')
        else:
            printf_utf8_to_gbk(bold_yellow(u'程序可能不安全') + '\n')


######################
# display raw checks #
######################


def memoize(f):
    ''' Decorator to wrap a function with memoizing '''
    cache = {}

    def helper(*args):
        if args not in cache:
            cache[args] = f(*args)
        return cache[args]

    return helper


@memoize
def format_path(path):
    '''
    Format a path.

    Return the shortest between the absolute path or the relative path.
    '''
    if not path:
        return None

    abs_path = os.path.realpath(path)
    # yuna os.cwd() and path are not the same drive
    if os.path.realpath(path).startswith(os.getcwd()):
        rel_path = os.path.relpath(os.path.realpath(path), os.getcwd())
        return min(abs_path, rel_path, key=len)
    else:
        return abs_path


def format_status(status):
    ''' Add colors to a status '''
    if status == 'ok':
        return bold_green(status)
    elif status == 'error':
        return bold_red(status)
    elif status == 'warning':
        return bold_yellow(status)
    elif status == 'unreachable':
        return bold_magenta(status)
    else:
        assert False, 'unexpected status'


def format_operands(operands):
    if not operands:
        return None

    operands = ('%d: %s' % (p.num, p.operand.repr) for p in operands)
    return ', '.join(operands)


def print_raw_checks(db, interprocedural):
    ''' Print all checks in the database, with very little processing '''
    header = [
        'context',
        'function',
        'file',
        'line',
        'col',
        'stmt',
        'check',
        'checker',
        'result',
        'operands',
        'info'
    ]
    order_by = 'call_context_id, statement_id, kind'

    if not interprocedural:
        header.pop(0)  # no context column if intraprocedural


    c = db.con.cursor()
    c.execute('SELECT * FROM checks ORDER BY %s' % order_by)
    rows = c.fetchall()

    # Format all rows
    for i, row in enumerate(rows):
        check = Check(row, db)
        statement = check.statement()
        function = statement.function()
        call_context = check.call_context()

        rows[i] = [call_context.str(),
                   function.pretty_name(),
                   format_path(statement.file_path()) or ' ',
                   str(statement.line_or(' ')),
                   str(statement.column_or(' ')),
                   str(statement.id),
                   CheckKind.short_name(check.kind),
                   CheckerName.short_name(check.checker),
                   Result.str(check.status),
                   format_operands(check.load_operands()) or ' ',
                   check.info or ' ']

        if not interprocedural:
            rows[i].pop(0)  # no context column if intraprocedural

    # Reorganize data by columns
    cols = zip(*([header] + rows))

    # Compute column widths by taking maximum length of values per column
    col_widths = [max(len(value) for value in col) for col in cols]

    # Print table
    printf_utf8_to_gbk(bold('# Checks') + '\n')
    printf_utf8_to_gbk('|' +
           '|'.join(' %s ' % head.ljust(width)
                    for head, width in zip(header, col_widths)) +
           '|\n')
    printf_utf8_to_gbk('+' + '+'.join('-' * (width + 2) for width in col_widths) + '+\n')
    for row in rows:
        fmt = ('|' +
               '|'.join(' %s ' + ' ' * (width - len(e))
                        for e, width in zip(row, col_widths)) +
               '|\n')
        row[-3] = format_status(row[-3])  # add colors for result column
        printf_utf8_to_gbk(fmt, *row)

    c.close()


##########
# report #
##########


class Report:
    ''' Represents an analysis report '''

    def __init__(self, db):
        self.db = db
        self.statement_reports = []

    def append(self, statement_report):
        self.statement_reports.append(statement_report)

    def __repr__(self):
        if not self.statement_reports:
            return 'Report([])'

        lines = ',\n'.join(map(repr, self.statement_reports))
        return 'Report([\n%s\n])' % lines


class StatementReport:
    ''' Represents a report on a statement '''

    def __init__(self,
                 db,
                 kind,
                 status,
                 statement_id,
                 call_context_ids,
                 checker_kind=None,
                 operands=None,
                 info=None):
        self.db = db
        self.kind = kind
        self.status = status
        self.statement_id = statement_id
        self.call_context_ids = call_context_ids
        self.checker_kind = checker_kind
        self.operands = operands
        self.info = info

    def statement(self):
        return self.db.statements[self.statement_id]

    def call_contexts(self):
        return (self.db.call_contexts[id]
                for id in self.call_context_ids)

    def load_operands(self):
        ''' Return the operands, or None '''
        if not self.operands:
            return None

        operands = json.loads(self.operands)
        return [NumOperandPair(no, self.db.operands[id])
                for no, id in operands]

    def load_info(self):
        ''' Return the info, or None '''
        if not self.info:
            return None

        return json.loads(self.info)

    def checker_name(self):
        if self.kind==CheckKind.UNREACHABLE:
            return 'unreachable'
        return CheckerName.short_name(self.checker_kind)

    def __repr__(self):
        s = ('StatementReport('
             'kind=%s, '
             'checker=%s,'
             'status=%s, '
             'statement_id=%d, '
             'context_ids=%r, '
             'operands=%s, '
             'info=%s)')
        return s % (CheckKind.short_name(self.kind),
                    self.checker_name(),
                    Result.str(self.status),
                    self.statement_id,
                    self.call_context_ids,
                    self.operands,
                    self.info)


def generate_report(db, status_filter=None, analyses_filter=None):
    '''
    Generate an analysis report.

    Arguments:
        status_filter(list): List of status, or None
        analyses_filter(list): List of checkers, or None
    '''
    report = Report(db)

    # Parse filters
    if status_filter is not None:
        status_filter = tuple(map(Result.from_str, status_filter))

    if analyses_filter is not None:
        analyses_filter = tuple(map(CheckerName.from_short_name,
                                    analyses_filter))

    display_oks = (status_filter is None or Result.OK in status_filter)
    display_unreachables = ((status_filter is None or
                             Result.UNREACHABLE in status_filter) and
                            (analyses_filter is None or
                             CheckerName.DEAD_CODE in analyses_filter))

    # Generate where clause
    where = []

    if status_filter is not None:
        if not status_filter:
            where = ['0=1']  # status_filter=[], filter everything
        else:
            where.append(' OR '.join('(status=%d)' % status
                                     for status in status_filter))

    if analyses_filter is not None:
        if not analyses_filter:
            where = ['0=1']  # analyses_filter=[], filter everything
        elif len(analyses_filter) == len(args.analyses):
            pass  # nothing to filter
        else:
            where.append(' OR '.join('(checker=%d)' % checker
                                     for checker in analyses_filter))

    where = ' AND '.join('(%s)' % clause for clause in where)

    if display_unreachables and not display_oks:
        # Only show unreachable statements if the statement is unreachable for
        # all calling contexts. To detect this, we need to make sure to get all
        # checks from the DeadCodeChecker, especially 'ok' checks.
        where = '(%s) OR (checker=%d)' % (where, CheckerName.DEAD_CODE)

    if where:
        where = 'WHERE %s' % where

    order_by = 'ORDER BY statement_id, call_context_id'

    # Execute query
    c = db.con.cursor()
    c.execute('SELECT * FROM checks %s %s' % (where, order_by))

    stmt_id_key = operator.itemgetter(ChecksTable.STATEMENT_ID)
    context_id_key = operator.itemgetter(ChecksTable.CALL_CONTEXT_ID)

    for statement_id, statement_checks in itertools.groupby(c,
                                                            key=stmt_id_key):
        # Iterate over the checks for statement = statement_id
        statement_results = set()
        statement_context_ids = list()
        statement_checkers = set()
        statement_errors = collections.defaultdict(list)
        statement_warnings = collections.defaultdict(list)
        statement_oks = collections.defaultdict(list)

        for context_id, checks in itertools.groupby(statement_checks,
                                                    key=context_id_key):
            # Iterate over the checks for statement = statement_id
            # and context = context_id
            result, errors, warnings, oks, checkers = \
                generate_statement_result(checks,
                                          keep_oks=display_oks,
                                          keep_checkers=display_unreachables)
            statement_results.add(result)
            statement_context_ids.append(context_id)
            if display_unreachables:
                statement_checkers.union(checkers)
            for error in errors:
                statement_errors[error].append(context_id)
            for warning in warnings:
                statement_warnings[warning].append(context_id)
            if display_oks:
                for ok in oks:
                    statement_oks[ok].append(context_id)

        if statement_results == {Result.UNREACHABLE}:
            # Statement is unreachable for all the calling contexts,
            # check that we want unreachable checks and that it comes from dca
            if display_unreachables and CheckerName.DEAD_CODE in checkers:
                report.append(StatementReport(
                    db=db,
                    kind=CheckKind.UNREACHABLE,
                    status=Result.UNREACHABLE,
                    statement_id=statement_id,
                    call_context_ids=statement_context_ids
                ))
        else:
            # yuna :add checker to display
            for check, context_ids in statement_errors.items():
                report.append(StatementReport(db=db,
                                              kind=check.kind,
                                              checker_kind=check.chekcer,
                                              status=Result.ERROR,
                                              statement_id=statement_id,
                                              call_context_ids=context_ids,
                                              operands=check.operands,
                                              info=check.info))
            for check, context_ids in statement_warnings.items():
                report.append(StatementReport(db=db,
                                              kind=check.kind,
                                              checker_kind=check.chekcer,
                                              status=Result.WARNING,
                                              statement_id=statement_id,
                                              call_context_ids=context_ids,
                                              operands=check.operands,
                                              info=check.info))
            for check, context_ids in statement_oks.items():
                report.append(StatementReport(db=db,
                                              kind=check.kind,
                                              checker_kind=check.chekcer,
                                              status=Result.OK,
                                              statement_id=statement_id,
                                              call_context_ids=context_ids,
                                              operands=check.operands,
                                              info=check.info))

    c.close()
    return report


##################
# report formats #
##################


class Formatter(object):
    ''' Base class for formatters '''

    def __init__(self, output, verbosity):
        '''
        Arguments:
            output(file): output file
            verbosity(int): verbosity level
        '''
        self.output = output
        self.verbosity = verbosity

    def format(self, report,show_call_context, result_level):
        raise NotImplementedError

class SunWiseFormatter(Formatter):
    ''' SunWise output formatter '''

    def __init__(self, output, verbosity):
        super(SunWiseFormatter, self).__init__(output, verbosity)
        self.sources = {}

    # error, warning, unreachable, ok
    RESULT_ORDER = [3, 1, 0, 2]

    @classmethod
    def sorting_key(cls, report):
        statement = report.statement()
        return (cls.RESULT_ORDER[report.status],
                statement.file_id_or(-1),
                statement.line_or(-1),
                statement.column_or(-1),
                report.kind)

    def write_path(self, file):
        printf_utf8_to_gbk(bold('%s: '), format_path(file.path) if file else '?',
               file=self.output)

    def write_in_function(self, function):
        printf_utf8_to_gbk(u"在函数'%s'中:", function.pretty_name(), file=self.output)

    def write_newline(self):
        printf_utf8_to_gbk('\n', file=self.output)

    def write_source_location(self, statement):
        printf_utf8_to_gbk(bold('%s:%s:%s: '),
               format_path(statement.file_path()) or '?',
               statement.line_or('?'),
               statement.column_or('?'),
               file=self.output)
    def write_hasa_and_checker_title(self, checker_name):
        printf_utf8_to_gbk('[hasa][analyzer][%s]',checker_name, file=self.output)

    def write_hasa_and_trace_title(self, count):
        title_str = ""
        if count == 0:
            title_str = '[hasa][analyzer][trace]'
        else :
            title_str = '[hasa][analyzer]'+  ' '* count + '[trace]['+str(count)+']'

        printf_utf8_to_gbk(title_str, file=self.output)

    RESULT_RAW_STR = ['safe', 'warning', 'error', 'unreachable']

    RESULT_FORMATTED_STR = [bold_green('safe'),
                            bold_yellow('warning'),
                            bold_red('error'),
                            bold_magenta('unreachable')]

    def write_status(self, result):
        printf_utf8_to_gbk('%s: ' % SunWiseFormatter.RESULT_RAW_STR[result],
               file=self.output)

    def write_note(self):
        printf_utf8_to_gbk('%s: ' % bold_blue('note'), file=self.output)

    def source_location_indent(self, statement):
        return len('%s:%s:%s: ' % (format_path(statement.file_path()) or '?',
                                   statement.line_or('?'),
                                   statement.column_or('?')))

    def status_indent(self, result):
        return len('%s: ' % SunWiseFormatter.RESULT_RAW_STR[result])

    def write_message(self, statement, result, message):
        if '\n' in message:
            # Assume write_source_location and write_status have been called
            n = self.source_location_indent(statement)
            n += self.status_indent(result)
            #message = message.replace('\n', '\n' + ' ' * n)
            message = message.replace('\n', ' ')

        printf_utf8_to_gbk('%s\n', message, file=self.output)

    def load_source_code(self, path):
        if path not in self.sources:
            try:
            
                with io.open(path.decode('utf-8'), 'r',
                             encoding='utf-8',
                             errors='ignore') as f:
                    self.sources[path] = tuple(f.readlines())
            except IOError:
                printf_utf8_to_gbk(u'warning: 无法打开文件%s\n', path,
                       file=sys.stderr)
                self.sources[path] = []

        return self.sources[path]

    def write_source_code(self, statement, pointer_color=bold_green):
        if statement.file_id is not None and statement.line is not None:
            source_code = self.load_source_code(statement.file_path())

            if statement.line <= len(source_code):
                line = source_code[statement.line - 1].rstrip()
                # yuna: 不用printf_utf8_to_gbk,源文件有可能不是utf8
                printf(line + '\n', file=self.output)
                if statement.column is not None:
                    footer = ''.join('\t' if c == '\t' else ' '
                                     for c in line[:statement.column - 1])
                    footer += pointer_color('^')
                    printf(footer + '\n', file=self.output)

    def write_call_context(self, statement, call_context,max_depth=3):
        count = 0
        self.write_hasa_and_trace_title(count)

        self.write_source_location(statement)
        self.write_note()

        if call_context.empty():
            function = statement.function()
            printf_utf8_to_gbk("被入口点'%s'调用\n",
                   function.pretty_name(), file=self.output)
            return

        printf_utf8_to_gbk('被调用:\n', file=self.output)
        for _ in range(max_depth):
            if call_context.empty():
                return

            call_statement = call_context.call()
            function = call_context.function()

            count = count + 1
            self.write_hasa_and_trace_title(count)
            self.write_source_location(call_statement)
            printf_utf8_to_gbk("函数'%s'\n", function.pretty_name(), file=self.output)

            #self.write_source_code(call_statement)

            call_context = call_context.parent()

    def print_filter_summary(self, filtered_count_map):
        total = 0
        for count in filtered_count_map.values():
            total = total + count

        printf_utf8_to_gbk('\n')
        printf_utf8_to_gbk(u'过滤后:\n')
        printf_utf8_to_gbk(u'过滤后所有的检查数        : %s\n',
               total)
        printf_utf8_to_gbk(u'过滤后所有的不可达检查数  : %s\n',
               filtered_count_map['unreachable']
               if filtered_count_map['unreachable']
               else '0')
        printf_utf8_to_gbk(u'过滤后不安全的检查数      : %s\n',
               filtered_count_map['error']
               if filtered_count_map['error']
               else '0')
        printf_utf8_to_gbk(u'过滤后所有的警告数        : %s\n',
               filtered_count_map['warning']
               if filtered_count_map['warning']
               else '0')



    def format(self, report, show_call_context, result_level):
        statement_reports = report.statement_reports

        # Sort reports
        statement_reports.sort(key=self.sorting_key)

        # map
        filtered_count_map = {}
        for raw_str in SunWiseFormatter.RESULT_RAW_STR:
            filtered_count_map[raw_str] = 0

        for statement_report in statement_reports:
            statement = statement_report.statement()
            function = statement.function()
            message = generate_message(statement_report, self.verbosity,  result_level)


            # yuna: filter
            if message == "":
                continue 
            status_raw_str = SunWiseFormatter.RESULT_RAW_STR[statement_report.status]
            if status_raw_str == 'safe':
                continue
            filtered_count_map[status_raw_str] = filtered_count_map[status_raw_str] + 1

            checker= statement_report.checker_name()          
            self.write_hasa_and_checker_title(checker)
            self.write_source_location(statement)
            self.write_status(statement_report.status)
            self.write_message(statement, statement_report.status, message)

            if show_call_context :
                for call_context in statement_report.call_contexts():
                    self.write_call_context(statement, call_context)

        self.print_filter_summary(filtered_count_map)

# available formats
formats = {
    'sunwise': SunWiseFormatter,
}


###################
# report messages #
###################


def generate_message(report, verbosity, result_level):
    ''' Generate a message for the given statement report and verbosity '''

    # yuna 
    if is_filtered_by_check_kind(result_level, report.kind):
        return ""
    
    message = GENERATE_MESSAGE_MAP[report.kind](report, verbosity, result_level)
    # yuna filter
    if is_filtered_by_message(result_level, message):
        return ""

    return message


def is_variable_name(s):
    ''' Return true if the given string is a variable name '''
    # First letter is alpha or underscore
    # Everything else is alphanumeric or underscore
    return (s and
            (s[0].isalpha() or s[0] == '_') and
            all(c.isalnum() or c == '_' for c in s))


def ordinal_str(num):
    assert num >= 1

    if num == 1:
        return 'first'
    elif num == 2:
        return 'second'
    elif num == 3:
        return 'third'

    if num > 9:
        if str(num)[-2] == '1':
            return '%dth' % num

    last_digit = num % 10
    if last_digit == 1:
        return '%dst' % num
    elif last_digit == 2:
        return '%dnd' % num
    elif last_digit == 3:
        return '%drd' % num
    else:
        return '%dth' % num


def statement_operand_str(statement, num):
    '''
    Return a string to represent the num-th operand of the given statement
    '''
    if (statement.kind == StatementKind.ASSIGNMENT or
            statement.kind == StatementKind.UNARY_OPERATION):
        # TODO: rigth hand side or right operand
        return u'右操作数'
    elif (statement.kind == StatementKind.BINARY_OPERATION or
            statement.kind == StatementKind.COMPARISON):
        if num == 0:
            return u'左操作数'
        else:
            return u'右操作数'
    elif statement.kind == StatementKind.RETURN:
        return u'返回值'
    elif statement.kind == StatementKind.ALLOCATE:
        # TODO: size operand
        return u'操作数'
    elif statement.kind == StatementKind.POINTER_SHIFT:
        if num == 0:
            # TODO: base pointer
            return u'基址操作数'
        else:
            return u'第%s操作数' % num
    elif statement.kind == StatementKind.LOAD:
        return u'指针'
    elif statement.kind == StatementKind.STORE:
        if num == 0:
            return u'指针'
        else:
            # stored value
            return u'存入的值'
    elif (statement.kind == StatementKind.EXTRACT_ELEMENT or
            statement.kind == StatementKind.INSERT_ELEMENT):
        return u'第%s操作数' % (num + 1)
    elif (statement.kind == StatementKind.CALL or
            statement.kind == StatementKind.INVOKE):
        if num == 0:
            return u'函数指针'
        else:
            return u'第%参数' % num
    elif (statement.kind == StatementKind.LANDING_PAD or
            statement.kind == StatementKind.RESUME):
        return u'操作数'
    else:
        assert False, 'unexpected kind'


def memory_location_str(mem_loc):
    ''' Return a string to represent the given memory location '''
    info = mem_loc.load_info()

    # yuna: info may be null(abstract domain: congruence)
    if mem_loc.kind == MemoryLocationKind.LOCAL:
        if info and 'name' in info:
            return u"局部变量'%s'" % info['name']
        else:
            return u'未命名的局部变量'
    elif mem_loc.kind == MemoryLocationKind.GLOBAL:
        if 'demangle' in info:
            return u"全局变量'%s'" % info['demangle']
        elif 'name' in info:
            return u"全局变量'%s'" % info['name']
        elif 'cst' in info:
            return u"全局常量'%s'" % info['cst']
        else:
            assert False, 'unexpected global memory location'
    elif mem_loc.kind == MemoryLocationKind.FUNCTION:
        function = mem_loc.db.functions[info['id']]
        return u"函数'%s'" % function.pretty_name()
    elif mem_loc.kind == MemoryLocationKind.AGGREGATE:
        return u'聚合变量'
    elif mem_loc.kind == MemoryLocationKind.VA_ARG:
        return u'变量参数列表'
    elif mem_loc.kind == MemoryLocationKind.ABSOLUTE_ZERO:
        return u'0'
    elif mem_loc.kind == MemoryLocationKind.ARGV:
        return u'argv'
    elif mem_loc.kind == MemoryLocationKind.DYN_ALLOC:
        call = mem_loc.db.statements[info['call_id']]
        function = call.function()

        if call.line is not None and call.column is not None:
            return u"在'%s:%d:%d'分配的动态内存" % (
                function.pretty_name(),
                call.line,
                call.column
            )
        else:
            return u"在'%s'分配的动态内存" % function.pretty_name()
    else:
        assert False, 'unexpected kind'


def generate_unreachable_message(report, verbosity, result_level):
    if report.status == Result.OK:
        return u'可达语句'
    elif report.status == Result.UNREACHABLE:
        return u'不可达代码'
    else:
        assert False, 'unexpected status'


def generate_unexpected_operand_message(report, verbosity, result_level):
    assert report.status == Result.ERROR
    return u'unexpected operand'


def generate_uninitialized_variable_message(report, verbosity, result_level):
    if report.status == Result.OK:
        return u'操作数已初始化'

    (num, operand), = report.load_operands()
    if ValueKind.BEGIN_CONSTANT <= operand.kind <= ValueKind.END_CONSTANT:
        s = statement_operand_str(report.statement(), num)
    elif ValueKind.BEGIN_VARIABLE <= operand.kind <= ValueKind.END_VARIABLE:
        if is_variable_name(operand.repr):
            s = u"变量'%s'" % operand.repr
        else:
            s = u"表达式'%s'" % operand.repr
    else:
        assert False, u'unexpected operand'

    if report.status == Result.WARNING:
        s += u'可能未初始化'
    elif report.status == Result.ERROR:
        s += u'未初始化'
    else:
        assert False, 'unexpected status'

    return s


def generate_assert_message(report, verbosity, result_level):
    if report.status == Result.OK:
        return u'断言成立'
    elif report.status == Result.WARNING:
        return  u'断言可能不成立'
    elif report.status == Result.ERROR:
        return u'断言不成立'
    else:
        assert False, 'unexpected status'


def generate_division_by_zero_message(report, verbosity, result_level):
    if report.status == Result.OK:
        return u'除数安全'
    elif report.status == Result.ERROR:
        return u'除数为0'

    assert report.status == Result.WARNING
    (_, operand), = report.load_operands()
    interval = Interval.from_dict(report.load_info())

    if is_filtered_by_interval(result_level, interval):
        return ''

    s = ''
    if not interval.is_top():
        if is_variable_name(operand.repr):
            s = u'，%s' % interval.to_constraints_sunwise(operand.repr)
        else:
            s = u'，%s' % interval.to_constraints_sunwise(u'除数')
    else:
        s = u'除数可能为0'

    return s

def generate_shift_count_message(report, verbosity, result_level):
    if report.status == Result.OK:
        return u'位移数安全'

    if (report.status != Result.ERROR and report.status != Result.WARNING):
        assert False, 'unexpected status'

    (_, operand), = report.load_operands()
    interval = Interval.from_dict(report.load_info())
    if is_filtered_by_interval(result_level, interval):
        return ''

    s = ''
    if ((not interval.is_top())
       and operand.kind != ValueKind.INTEGER_CONSTANT):
        if is_variable_name(operand.repr):
            s = '%s，' % interval.to_constraints_sunwise(operand.repr)
        else:
            s = '%s，' % interval.to_constraints_sunwise('移位数')
 
    n = interval.bit_width - 1
    s += u'移位数的范围应为[0, %d]' % n

    return s


def generate_integer_overflow_message(report, verbosity, result_level, signedness, kind):
    if report.status == Result.OK:
        return u'%s整数不%s' % (signedness, kind)

    if report.status != Result.ERROR and report.status != Result.WARNING:
        assert False, 'unexpected status'
    
    (_, left_operand), (_, right_operand) = report.load_operands()

    s = u"在操作数'%s'和'%s'中，" % (
        left_operand.repr,
        right_operand.repr
    )
 
    info = report.load_info()
    left_interval = Interval.from_dict(info['left'])
    right_interval = Interval.from_dict(info['right'])

    if is_filtered_by_interval(result_level, left_interval):
        return ''
    if is_filtered_by_interval(result_level, right_interval):
        return ''

    ops = []
    if ((not left_interval.is_top()) and
            left_operand.kind != ValueKind.INTEGER_CONSTANT):
        if is_variable_name(left_operand.repr):
            ops.append(left_interval.to_constraints_sunwise(left_operand.repr))
        else:
            ops.append(left_interval.to_constraints_sunwise(u'左操作数'))
    if ((not right_interval.is_top()) and
            right_operand.kind != ValueKind.INTEGER_CONSTANT):
        if is_variable_name(right_operand.repr):
            ops.append(right_interval.to_constraints_sunwise(right_operand.repr))
        else:
            ops.append(right_interval.to_constraints_sunwise(u'右操作数'))

    if ops:
        s += u'%s' % ', '.join(ops)

    if report.status == Result.ERROR:
        s += u'，%s整数%s' % (signedness, kind)
    elif report.status == Result.WARNING:
        s += u'，%s整数可能%s' % (signedness, kind)
    return s


def generate_null_pointer_deref_message(report, verbosity, result_level):
    if report.status == Result.OK:
        return u'指针非空'

    (num, operand), = report.load_operands()
    if ValueKind.BEGIN_CONSTANT <= operand.kind <= ValueKind.END_CONSTANT:
        s = statement_operand_str(report.statement(), num)
    elif ValueKind.BEGIN_VARIABLE <= operand.kind <= ValueKind.END_VARIABLE:
        s = u"指针'%s'" % operand.repr
    else:
        assert False, 'unexpected operand'

    if report.status == Result.WARNING:
        s += u'可能为空'
    elif report.status == Result.ERROR:
        s += u'为空'
    else:
        assert False, 'unexpected status'

    return s


def generate_null_pointer_cmp_message(report, verbosity, result_level):
    assert report.status == Result.ERROR
    (num, _), = report.load_operands()
    if num == 0:
        return u'无效的指针比较，左操作数为空'
    else:
        return u'无效的指针比较，右操作数为空'


def generate_invalid_pointer_cmp_message(report, verbosity, result_level):
    assert report.status == Result.ERROR
    (_, operand), = report.load_operands()
    return u"指针'%s'无效" % operand.repr


def generate_pointer_cmp_message(report, verbosity, result_level):
    if report.status == Result.OK:
        return u'指针比较安全'
    elif report.status == Result.ERROR:
        return u'无效的指针比较，指针指向不同对象'
    elif report.status == Result.WARNING:
        return u'无效的指针比较，指针可能指向不同对象'
    else:
        assert False, 'unexpected status'


def generate_pointer_overflow_message(report, verbosity, result_level):
    if report.status == Result.OK:
        return u'指针算术运算安全'
    elif report.status == Result.WARNING:
        return u'指针可能溢出'
    elif report.status == Result.ERROR:
        return u'指针溢出'
    else:
        assert False, 'unexpected status'


def generate_invalid_pointer_deref_message(report, verbosity, result_level):
    assert report.status == Result.ERROR
    (_, operand), = report.load_operands()
    s = u"指针'%s'无效" % operand.repr
    return s


def generate_unknown_memory_access_message(report, verbosity, result_level):
    assert report.status == Result.WARNING
    (_, operand), = report.load_operands()
    s = u'内存访问可能不安全'
    s += u"，无法推断指针'%s'的信息" % operand.repr
    return s


def generate_unaligned_pointer_message(report, verbosity, result_level):
    if report.status == Result.OK:
        return u'指针已对齐'

    if report.status == Result.WARNING:
        s = u'内存访问可能未对齐'
    elif report.status == Result.ERROR:
        s = u'内存访问未对齐'
    else:
        assert False, 'unexpected status'

    info = report.load_info()
    requirement = Congruence.from_dict(info['requirement'])
    s += u'，访问需要%d字节对齐' % requirement.a

    offset = Congruence.from_dict(info['offset'])
    if offset.is_top():
        s += u'，指针偏移值未知'
    elif offset.a == 0:
        s += u'，指针偏移为%d字节' % offset.b
    elif offset.b == 0:
        s += u'，指针偏移为%d字节的倍数' % offset.a,
    else:
        s += u'，指针偏移为%d %% %d字节' % (
            offset.b,
            offset.a
        )

    points_to = []
    for block_info in info['points_to']:
        mem_loc_id = block_info['id']
        mem_loc = report.db.memory_locations[mem_loc_id]

        if mem_loc.kind == MemoryLocationKind.ABSOLUTE_ZERO:
            continue

        line = memory_location_str(mem_loc)

        if 'congruence' in block_info:
            congruence = Congruence.from_dict(block_info['congruence'])
            if not congruence.is_top():
                line += u'对齐%d字节' % congruence.a

        points_to.append(line)

    # make the output deterministic
    points_to.sort()

    if len(points_to) == 1:
        s += u'，指针指向' + points_to[0]
    elif len(points_to) > 1:
        lines = ''.join('，\t* %s' % p for p in points_to)
        s += u'，指针指向为:' + lines

    return s


def generate_buffer_overflow_message(report, verbosity, result_level):
    if report.status == Result.OK:
        return u'内存访问安全'

    info = report.load_info()
    kinds = set(block_info['kind'] for block_info in info['points_to'])

    if len(kinds) > 1:
        # different kind of errors, use a generic message
        if report.status == Result.WARNING:
            s = u'可能访问无效内存'
        elif report.status == Result.ERROR:
            s = u'访问无效内存'
        else:
            assert False, 'unexpected status'
    elif kinds == {BufferOverflowCheckKind.FUNCTION}:
        assert report.status == Result.ERROR
        s = u'函数指针解引用'
    elif kinds == {BufferOverflowCheckKind.USE_AFTER_FREE}:
        if report.status == Result.WARNING:
            s = u'可能释放后再使用'
        elif report.status == Result.ERROR:
            s = u'释放后再使用'
        else:
            assert False, 'unexpected status'
    elif kinds == {BufferOverflowCheckKind.USE_AFTER_RETURN}:
        if report.status == Result.WARNING:
            s = u'可能返回后使用'
        elif report.status == Result.ERROR:
            s = u'返回后使用'
        else:
            assert False, 'unexpected status'
    elif kinds == {BufferOverflowCheckKind.HARDWARE_ADDRESSES}:
        if report.status == Result.WARNING:
            s = '可能访问无效内存'
        elif report.status == Result.ERROR:
            s = '访问无效内存'
        else:
            assert False, 'unexpected status'

        offset = Interval.from_dict(info['offset'])
        if offset.is_constant():
            s += u'访问绝对地址0x%x' % offset.lb.n
        elif not offset.is_top():
            s += u'访问绝对地址范围[0x%x, 0x%x]' % (
                offset.lb.n,
                offset.ub.n
            )

        return s
    elif kinds == {BufferOverflowCheckKind.OUT_OF_BOUND}:
        if report.status == Result.WARNING:
            s = u'缓冲区可能溢出'
        elif report.status == Result.ERROR:
            s = u'缓冲区溢出'
        else:
            assert False, 'unexpected status'
    else:
        assert False, 'unexpected kind'

    # 判断offset的上下界
    offset = Interval.from_dict(info['offset'])
    if is_filtered_by_offset(result_level, offset):
        return ''

    # Size of an array element, or None if it's not an array access
    array_element_size = info.get('array_element_size', None)

    # points_to信息
    points_to = []
    for block_info in info['points_to']:
        status = block_info['status']
        kind = block_info['kind']
        mem_loc_id = block_info['id']
        mem_loc = report.db.memory_locations[mem_loc_id]

        line = memory_location_str(mem_loc)

        if kind == BufferOverflowCheckKind.OUT_OF_BOUND:
            size = Interval.from_dict(block_info['size'])

            if array_element_size:
                if size.is_constant():
                    n = size.lb.n // array_element_size
                    line += u'有%d个元素' % n
                elif not size.ub.is_max():
                    ub = size.ub.n // array_element_size
                    line += u'至少有%d个元素' % ub
            else:
                if size.is_constant():
                    line += u'有%d个字节' % size.lb.n
                elif not size.ub.is_max():
                    line += u'至少有%d个字节' % size.ub.n

        if len(info['points_to']) == 1:
            # no need for further explanation
            points_to.append(line)
            break

        if kind == BufferOverflowCheckKind.FUNCTION:
            assert status == Result.ERROR
            line += u'是一个函数'
        elif kind == BufferOverflowCheckKind.USE_AFTER_FREE:
            if status == Result.WARNING:
                line += u'可能被释放'
            elif status == Result.ERROR:
                line += u'已被释放'
            else:
                assert False, 'unexpected status'
        elif kind == BufferOverflowCheckKind.USE_AFTER_RETURN:
            if status == Result.WARNING:
                line += u'可能超出作用域'
            elif status == Result.ERROR:
                line += u'已经超出作用域'
            else:
                assert False, 'unexpected status'
        elif kind == BufferOverflowCheckKind.HARDWARE_ADDRESSES:
            if status == Result.WARNING:
                line += u'可能不是有效的硬件地址'
            elif status == Result.ERROR:
                line += u'不是有效的硬件地址'
            else:
                # yuna:may be  status=3 assert false
                assert False, 'unexpected status'
        elif kind == BufferOverflowCheckKind.OUT_OF_BOUND:
            if status == Result.OK:
                line += u'是有效内存'
            elif status == Result.WARNING:
                line += u'可能存在缓冲区溢出'
            elif status == Result.ERROR:
                line += u'存在缓冲区溢出'
            else:
                assert False, 'unexpected status'
        else:
            assert False, 'unexpected kind'

        points_to.append(line)

    # 访问信息，数组
    if kinds == {BufferOverflowCheckKind.OUT_OF_BOUND} and array_element_size:
        # Out of bound array access
        offset = Interval.from_dict(info['offset'])
        offset = offset.sign_cast(Signedness.SIGNED)

        if offset.is_constant():
            n = offset.lb.n // array_element_size
            # 使用=而不是+=去除掉抬头
            s = u'访问数组下标%d' % n
        elif not offset.ub.is_max():
            ub = offset.ub.n // array_element_size
            if not offset.lb.is_min():
                lb = offset.lb.n // array_element_size
                s = u'访问数组下标范围为[%d, %d]' % (lb, ub)
            else:
                s = u'访问数组下标范围为[%d, %d]' % (lb, ub)
        else:
            # 无法计算
            s = u'无法计算下标范围'

        if len(points_to) == 1:
            s += u'，%s' % points_to[0]
        else:
            s += u':%s' % ''.join('\n\t* %s' % p for p in points_to)

        return s

    (_, operand), _ = report.load_operands()
    s += u"，指针 '%s'" % operand.repr

    if BufferOverflowCheckKind.OUT_OF_BOUND in kinds:
        offset = Interval.from_dict(info['offset'])
        offset = offset.sign_cast(Signedness.SIGNED)

        if offset.is_constant():
            n = offset.lb.n
            s += u'偏移为%d个字节' % n
        elif not offset.ub.is_max():
            ub = offset.ub.n
            if not offset.lb.is_min():
                lb = offset.lb.n
                s += u'偏移范围为[%d, %d]字节' % (lb, ub)
            else:
                s += u'偏移范围为[%d, %d]字节' % (lb, ub)

    if len(points_to) == 1:
        s += u'，指针指向的%s' % points_to[0]
    else:
        s += u'，指针指向有:%s' % ''.join('\n\t* %s' % p for p in points_to)

    return s



def generate_strcpy_buffer_overflow_message(report, verbosity, result_level):
    if report.status == Result.OK:
        return u'安全调用strcpy()'
    elif report.status == Result.WARNING:
        return u'缓冲区可能溢出'
    elif report.status == Result.ERROR:
        return u'缓冲区溢出'
    else:
        assert False, 'unreachable'


def generate_ignored_store_message(report, verbosity, result_level):
    assert report.status == Result.WARNING
    (_, operand), = report.load_operands()
    s = u'忽略写内存'
    s += u"，无法推断指针'%s'信息" % operand.repr
    s += u'分析不是sound.'
    return s


def generate_ignored_memcpy_message(report, verbosity, result_level):
    assert report.status == Result.WARNING
    (_, operand), = report.load_operands()
    s = u'忽略函数memcpy()'
    s += u"，无法推断指针'%s'信息" % operand.repr
    s += u'分析不是sound.'
    return s


def generate_ignored_memmove_message(report, verbosity, result_level):
    assert report.status == Result.WARNING
    (_, operand), = report.load_operands()
    s = u'忽略函数memmove()'
    s += u"，无法推断指针'%s'信息" % operand.repr
    s += u'分析不是sound.'
    return s


def generate_ignored_memset_message(report, verbosity, result_level):
    assert report.status == Result.WARNING
    (_, operand), = report.load_operands()
    s = u'忽略函数memset()'
    s += u"，无法推断指针'%s'信息" % operand.repr
    s += u'分析不是sound.'
    return s


def generate_ignored_free_message(report, verbosity, result_level):
    assert report.status == Result.WARNING
    (_, operand), = report.load_operands()
    s = u'忽略内存回收'
    s += u"，无法推断指针'%s'信息" % operand.repr
    s += u'分析不是sound.'
    return s


def generate_ignored_call_side_effect_on_pointer_param_message(report,
                                                               verbosity, result_level):
    assert report.status == Result.WARNING
    (_, operand), = report.load_operands()
    info = report.load_info()
    function_id = info['fun_id']
    function = report.db.functions[function_id]
    s = u"忽略调用函数 '%s'存在的副作用" % function.pretty_name()
    s += u"，无法推断指针'%s'信息." % operand.repr
    s += u' 分析不是sound.'
    return s

def generate_ignored_call_side_effect_message(report, verbosity, result_level):
    assert report.status == Result.WARNING
    info = report.load_info()
    function_id = info['fun_id']
    function = report.db.functions[function_id]
    s = u"忽略调用外部函数'%s'存在的副作用."
    s = s % function.pretty_name()
    s += u' 分析不是sound.'
    return s


def generate_call_inline_asm_message(report, verbosity, result_level):
    assert report.status == Result.OK
    return u'安全调用内联汇编代码'


def generate_unknown_function_call_message(report, verbosity, result_level):
    assert report.status == Result.WARNING
    (_, operand), = report.load_operands()
    s = u'函数调用可能不安全'
    s += u"，无法推断指针'%s'信息" % operand.repr
    return s


def generate_function_call_message(report, verbosity, result_level):
    info = report.load_info()

    if report.status == Result.OK:
        s = '安全调用函数'

        callees = []
        for block_info in info['points_to']:
            function_id = block_info['fun_id']
            function = report.db.functions[function_id]
            callees.append("'%s'" % function.pretty_name())

        if len(callees) == 1:
            s += u'%s' % callees[0]
        else:
            lines = ''.join('\n\t* %s' % c for c in callees)
            s += u'，调用的函数为:' + lines

        return s

    if report.status == Result.WARNING:
        s = u'可能为无效的调用函数'
    elif report.status == Result.ERROR:
        s = u'无效的函数调用'
    else:
        assert False, 'unexpected status'

    (_, operand), = report.load_operands()
    s += u"，指针'%s'指向" % operand.repr

    callees = []
    for block_info in info['points_to']:
        status = block_info['kind']
        mem_loc_id = block_info['id']
        mem_loc = report.db.memory_locations[mem_loc_id]

        if status == FunctionCallCheckKind.NOT_FUNCTION:
            line = u'%s不是函数' % memory_location_str(mem_loc)
        else:
            function_id = block_info['fun_id']
            function = report.db.functions[function_id]
            line = u"函数'%s'" % function.pretty_name()

            if status == FunctionCallCheckKind.WRONG_SIGNATURE:
                line += u'类型不匹配'
            elif status == FunctionCallCheckKind.OK:
                line += u'有效'
            else:
                assert False, 'unexpected kind'

        callees.append(line)

    if len(callees) == 1:
        s += ' %s' % callees[0]
    else:
        s += ':%s' % ''.join('\n\t* %s' % c for c in callees)

    return s


def generate_double_free_message(report, verbosity, result_level):
    if report.status == Result.OK:
        return u'内存回收安全'

    info = report.load_info()

    points_to = []
    all_dyn_alloc = True
    for block_info in info['points_to']:
        mem_loc_id = block_info['id']
        status = block_info['status']
        mem_loc = report.db.memory_locations[mem_loc_id]

        line = memory_location_str(mem_loc)
        if mem_loc.kind != MemoryLocationKind.DYN_ALLOC:
            assert status == Result.ERROR
            all_dyn_alloc = False
            line += u'不是动态分配的'
        elif status == Result.ERROR:
            line += u'已被释放'
        elif status == Result.WARNING:
            line += u'可能被释放'
        elif status == Result.OK:
            line += u'是有效的'
        else:
            assert False, 'unexpected status'

        points_to.append(line)

    if all_dyn_alloc:
        if report.status == Result.WARNING:
            s = u'可能释放两次内存'
        elif report.status == Result.ERROR:
            s = u'释放两次内存'
        else:
            assert False, 'unexpected status'
    else:
        if report.status == Result.WARNING:
            s = u'内存回收可能无效'
        elif report.status == Result.ERROR:
            s = u'内存回收无效'
        else:
            assert False, 'unexpected status'

    (_, operand), = report.load_operands()
    s += "，指针'%s'指向" % operand.repr

    if len(points_to) == 1:
        s += ' %s' % points_to[0]
    else:
        s += ':%s' % ''.join('\n\t* %s' % p for p in points_to)

    return s


GENERATE_MESSAGE_MAP = {
    CheckKind.UNREACHABLE: generate_unreachable_message,
    CheckKind.UNEXPECTED_OPERAND: generate_unexpected_operand_message,
    CheckKind.UNINITIALIZED_VARIABLE: generate_uninitialized_variable_message,
    CheckKind.ASSERT: generate_assert_message,
    CheckKind.DIVISION_BY_ZERO: generate_division_by_zero_message,
    CheckKind.SHIFT_COUNT: generate_shift_count_message,
    CheckKind.SIGNED_INT_UNDERFLOW: functools.partial(
        generate_integer_overflow_message,
        signedness=u'有符号',
        kind=u'下溢'),
    CheckKind.SIGNED_INT_OVERFLOW: functools.partial(
        generate_integer_overflow_message,
        signedness=u'有符号',
        kind=u'上溢'),
    CheckKind.UNSIGNED_INT_UNDERFLOW: functools.partial(
        generate_integer_overflow_message,
        signedness=u'无符号',
        kind=u'下溢'),
    CheckKind.UNSIGNED_INT_OVERFLOW: functools.partial(
        generate_integer_overflow_message,
        signedness=u'无符号',
        kind=u'上溢'),
    CheckKind.NULL_POINTER_DEREF: generate_null_pointer_deref_message,
    CheckKind.NULL_POINTER_COMPARISON: generate_null_pointer_cmp_message,
    CheckKind.INVALID_POINTER_COMPARISON: generate_invalid_pointer_cmp_message,
    CheckKind.POINTER_COMPARISON: generate_pointer_cmp_message,
    CheckKind.POINTER_OVERFLOW: generate_pointer_overflow_message,
    CheckKind.INVALID_POINTER_DEREF: generate_invalid_pointer_deref_message,
    CheckKind.UNKNOWN_MEMORY_ACCESS: generate_unknown_memory_access_message,
    CheckKind.UNALIGNED_POINTER: generate_unaligned_pointer_message,
    CheckKind.BUFFER_OVERFLOW: generate_buffer_overflow_message,
    CheckKind.STRCPY_BUFFER_OVERFLOW: generate_strcpy_buffer_overflow_message,
    CheckKind.IGNORED_STORE: generate_ignored_store_message,
    CheckKind.IGNORED_MEMORY_COPY: generate_ignored_memcpy_message,
    CheckKind.IGNORED_MEMORY_MOVE: generate_ignored_memmove_message,
    CheckKind.IGNORED_MEMORY_SET: generate_ignored_memset_message,
    CheckKind.IGNORED_FREE: generate_ignored_free_message,
    CheckKind.IGNORED_CALL_SIDE_EFFECT_ON_POINTER_PARAM:
        generate_ignored_call_side_effect_on_pointer_param_message,
    CheckKind.IGNORED_CALL_SIDE_EFFECT:
        generate_ignored_call_side_effect_message,
    CheckKind.FUNCTION_CALL_INLINE_ASSEMBLY: generate_call_inline_asm_message,
    CheckKind.UNKNOWN_FUNCTION_CALL_POINTER:
        generate_unknown_function_call_message,
    CheckKind.FUNCTION_CALL: generate_function_call_message,
    CheckKind.FREE: generate_double_free_message,
}


##########################
# command line interface #
##########################


def parse_arguments(argv):
    usage = '%(prog)s [options] file.db'
    description = 'Generate an analysis report from an output database'
    formatter_class = argparse.RawTextHelpFormatter
    parser = argparse.ArgumentParser(usage=usage,
                                     description=description,
                                     formatter_class=formatter_class)

    # Positional arguments
    parser.add_argument('file',
                        metavar='file.db',
                        help='Result database')

    # Optional arguments
    parser.add_argument('--version',
                        action=args.VersionAction,
                        nargs=0,
                        help='Show ikos version')
    parser.add_argument('--color',
                        dest='color',
                        metavar='',
                        help=args.help('Enable terminal colors:',
                                       args.color_choices,
                                       args.default_color),
                        choices=args.choices(args.color_choices),
                        default=args.default_color)
    parser.add_argument('-t', '--times',
                        dest='display_times',
                        metavar='',
                        help=args.help('Display timing results',
                                       args.display_times_choices,
                                       'no'),
                        choices=args.choices(args.display_times_choices),
                        default='no')
    parser.add_argument('-s', '--summary',
                        dest='display_summary',
                        metavar='',
                        help=args.help('Display the analysis summary',
                                       args.display_summary_choices,
                                       'no'),
                        choices=args.choices(args.display_summary_choices),
                        default='no')
    parser.add_argument('--display-raw-checks',
                        dest='display_raw_checks',
                        help='Display analysis raw checks',
                        action='store_true',
                        default=False)
    parser.add_argument('-f', '--format',
                        dest='format',
                        metavar='',
                        choices='sunwise',
                        default='sunwise')
    parser.add_argument('-o', '--report-file',
                        dest='report_file',
                        metavar='<file>',
                        help='Write the report into a file (default: stdout)',
                        default=sys.stdout,
                        type=argparse.FileType('w'))
    parser.add_argument('--web-port',
                        dest='web_port',
                        metavar='',
                        help='Listening port for ikos view',
                        default=8080,
                        type=int)
    parser.add_argument('--status-filter',
                        dest='status_filter',
                        metavar='',
                        help=args.help('Available status filters:',
                                       args.status_filters,
                                       args.default_status_filter),
                        action='append')
    parser.add_argument('--analyses-filter',
                        dest='analyses_filter',
                        metavar='',
                        help=args.help('Available analyses filters:',
                                       args.analyses,
                                       '*'),
                        action='append')
    parser.add_argument('-v', '--report-verbosity',
                        dest='report_verbosity',
                        metavar='[1-4]',
                        help='Report verbosity (default: 1)',
                        default=1,
                        type=int)
    # show call context
    parser.add_argument( '--show-call-context',
                        dest='show_call_context',
                        help='Show call context',
                        action='store_true',
                        default=False)    
    # choose different level message
    parser.add_argument('--result',
                        dest= 'result_level',
                        help = 'Choose the level of result(hign|all)',
                        metavar='',
                        choices=['high','all'],
                        default='all'
                        )

    opt = parser.parse_args(argv)

    # parse --status-filter
    opt.status_filter = args.parse_argument(parser,
                                            'status-filter',
                                            choices=args.status_filters,
                                            groups=None,
                                            default=args.default_status_filter,
                                            value=opt.status_filter)

    # parse --analyses-filter
    opt.analyses_filter = args.parse_argument(parser,
                                              'analyses-filter',
                                              choices=args.analyses,
                                              groups=None,
                                              default='*',
                                              value=opt.analyses_filter)

    # check for consistency between --web-port and -f=web
    if opt.web_port != 8080 and opt.format != 'web':
        parser.error('cannot use --web-port without --format=web')

    return opt


def ikos_view(opt, db):
    from ikos import view
    from ikos import log

    log.setup('info')
    v = view.View(db, port=opt.web_port)
    v.serve()


########################
# main for ikos-report #
########################

def main(argv):
    progname = os.path.basename(argv[0])

    # parse arguments
    opt = parse_arguments(argv[1:])

    # setup colors
    colors.setup(opt.color)

    if not os.path.isfile(opt.file):
        printf_utf8_to_gbk(u"%s: error: 没有这样的文件: \'%s\'\n",
               progname, opt.file, file=sys.stderr)
        sys.exit(1)

    try:
        # open result database
        db = OutputDatabase(opt.file)

        first = True

        # load settings
        settings = db.load_settings()

        # display timing results
        if opt.display_times != 'no':
            if not first:
                printf_utf8_to_gbk('\n')
            print_timing_results(db, opt.display_times == 'full')
            first = False

        # display summary
        if opt.display_summary != 'no':
            if not first:
                printf_utf8_to_gbk('\n')
            print_summary(db, opt.display_summary == 'full')
            first = False

        # display raw checks
        if opt.display_raw_checks:
            if not first:
                printf_utf8_to_gbk('\n')
            print_raw_checks(db, settings['procedural'] == 'interprocedural')
            first = False

        # start ikos-view
        if opt.format == 'web':
            ikos_view(opt, db)
            return

        # report
        if opt.format != 'no':
            if not first and opt.report_file is sys.stdout:
                printf_utf8_to_gbk('\n')

            # setup colors again (in case opt.color = 'auto')
            colors.setup(opt.color, file=opt.report_file)

            # generate report
            rep = generate_report(db,
                                  status_filter=opt.status_filter,
                                  analyses_filter=opt.analyses_filter)

            # format report
            formatter_class = formats[opt.format]
            formatter = formatter_class(opt.report_file, opt.report_verbosity)
            formatter.format(rep,opt.show_call_context, opt.result_level)

        # close database
        db.close()
    except sqlite3.DatabaseError as e:
        printf_utf8_to_gbk('%s: error: %s\n', progname, e, file=sys.stderr)
        sys.exit(1)
